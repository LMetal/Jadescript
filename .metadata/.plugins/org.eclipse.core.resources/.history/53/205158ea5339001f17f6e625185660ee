/*
 * generated by Xtext 2.34.0
 */
package org.xtext.globalTypes.validation;


import java.util.HashMap;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.xtext.globalTypes.myDsl.Choice;
import org.xtext.globalTypes.myDsl.ChoiceBranch;
import org.xtext.globalTypes.myDsl.ChoiceBranchL;
import org.xtext.globalTypes.myDsl.ChoiceL;
import org.xtext.globalTypes.myDsl.ForEach;
import org.xtext.globalTypes.myDsl.GlobalProtocol;
import org.xtext.globalTypes.myDsl.LocalProtocol;
import org.xtext.globalTypes.myDsl.Message;
import org.xtext.globalTypes.myDsl.Model;
import org.xtext.globalTypes.myDsl.MyDslPackage;
import org.xtext.globalTypes.myDsl.ReceiverL;
import org.xtext.globalTypes.myDsl.Role;
import org.xtext.globalTypes.myDsl.RoleSet;
import org.xtext.globalTypes.myDsl.RoleOne;
import org.xtext.globalTypes.myDsl.Roles;
import org.xtext.globalTypes.myDsl.SenderL;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MyDslValidator extends AbstractMyDslValidator {		
		
		@Check
		public void choiceMessageFromChoiceAgent(Choice c) {
			for(ChoiceBranch b: c.getBranches()) {
				if(b.getMessage().getSender() != c.getRole()) {
					error(
						"Sender of message must be role making choice",
						b.getMessage(),
						MyDslPackage.Literals.MESSAGE__SENDER
					);
				}
			}	
		}
		
		
		@Check
		public void choiceMessageFromChoiceAgentLocal(LocalProtocol lp) {
			for(ChoiceL c: EcoreUtil2.getAllContentsOfType(lp, ChoiceL.class)) {
				for(ChoiceBranchL b: c.getBranches()) {
					if(c.getRoleMakingChoice().getName().equals(lp.getProjectedRole())) {
						//se scelta interna deve essere un invio di messaggio
						System.out.println(b.getMessage().getSendReceive() instanceof ReceiverL);
						if(b.getMessage().getSendReceive() instanceof SenderL) {
							error(
								"Must send message when making a choice",
								b.getMessage(),
								MyDslPackage.Literals.MESSAGE_L__SEND_RECEIVE
							);
						}
					} else {
						//con scelta esterna ricevo messaggio dal ruolo che fa la scelta
						if(!b.getMessage().getSendReceive().getRole().equals(c.getRoleMakingChoice())) {
							error(
								"Must receive message from role making choice",
								b.getMessage(),
								MyDslPackage.Literals.MESSAGE_L__SEND_RECEIVE
							);
						}
					}
				}
			}
		}
		
		public void differentMessagesAtChoiceBranch(Choice c) {
			var messageTypeMap = new HashMap<String, Integer>();
			
			for(ChoiceBranch b: c.getBranches()) {
				if(messageTypeMap.containsKey(b.getMessage().getMessageType())) {
					error("Messages must be different",
							list.get(0),
							MyDslPackage.Literals.FOR_EACH__BRANCH);
				} else {
					
				}
			}
		}
		
		@Check
		public void noSelfMessage(Model global) {
			for(Message m: EcoreUtil2.getAllContentsOfType(global, Message.class)) {
				if(m.getSender() == m.getReceiver()) {
				error(
					"No self-message is allowed",
					m,
					MyDslPackage.Literals.MESSAGE__SENDER
				);
				
				error(
					"No self-message is allowed",
					m,
					MyDslPackage.Literals.MESSAGE__RECEIVER
				);
				}
			}
			
		}
		
		
		
		HashMap<RoleSet, RoleOne> getRolesetRef(Model m) {
			List<RoleSet> rolesetDef = EcoreUtil2.getAllContentsOfType(m, RoleSet.class);
			
			var references = new HashMap<RoleSet, RoleOne>();
			for(RoleSet r: rolesetDef) {
				references.put(r, r.getRef());
			}
			return references;
		}
		
		HashMap<RoleSet, RoleOne> getRolesetRef(GlobalProtocol g) {
			List<RoleSet> rolesetDef = EcoreUtil2.getAllContentsOfType(g, RoleSet.class);
			
			var references = new HashMap<RoleSet, RoleOne>();
			for(RoleSet r: rolesetDef) {
				references.put(r, r.getRef());
			}
			return references;
		}
		
		

		@Check
		public void rightRefRoleForEach(GlobalProtocol glob_p) {
			var rolesetRef = getRolesetRef(glob_p);
			List<ForEach> forEachList = EcoreUtil2.getAllContentsOfType(glob_p, ForEach.class);
			
			for(ForEach f : forEachList) {
				if(f.getRefRole() != rolesetRef.get(f.getRoleset())) {
					error(
						"Role cicling over Roleset must be referent of that Roleset",
						f,
						MyDslPackage.Literals.FOR_EACH__REF_ROLE
						);
				}
			}
		}
		

		@Check
		public void forEachVariableScope(Model m) {
			//ottengo tutti i ForEach
			List<ForEach> forEachList = EcoreUtil2.getAllContentsOfType(m, ForEach.class);
			//ottengo tutto, ogni action
			List<EObject> allActions = EcoreUtil2.getAllContentsOfType(m, EObject.class);
			
			//ciclo sui ForEach, controllo una variabile di ciclo alla volta
			for(ForEach f : forEachList) {
				//ottengo il contenuto del ForEach
				List<EObject> forEachActions = EcoreUtil2.getAllContentsOfType(f, EObject.class);
				//ciclo sul contenuto
				for(EObject action : allActions) {
					//può essere questo errore solo se ci si trova fuori dal foreach di cui si sta controllando la variabile
					if(!forEachActions.contains(action)) {
						//differisco per tipo di action e controllo
						if(action instanceof Message) {
							//se il sender o receiver di un messaggio fuori dal foreach è il ruolo definito nel foreach, errore
							Message message = (Message) action;
							if(message.getSender() == f.getLoopRole()) {
								error("Role not defined in this scope",
										message,
										MyDslPackage.Literals.MESSAGE__SENDER
										);}
							if(message.getReceiver() == f.getLoopRole()) {
								error("Role not defined in this scope",
										message,
										MyDslPackage.Literals.MESSAGE__RECEIVER
										);}
						}
						
						if(action instanceof Choice) {
							Choice choice = (Choice) action;
							if(choice.getRole() == f.getLoopRole()) {
								error("Role not defined in this scope",
										choice,
										MyDslPackage.Literals.CHOICE__ROLE
										);}
							}
						}
	
				}
			}
		}
		
		
		@Check
		public void noNestedFor(ForEach f) {
			List<ForEach> list = EcoreUtil2.getAllContentsOfType(f, ForEach.class);
			if(!list.isEmpty()) {
				error("Nested for are not allowed",
						list.get(0),
						MyDslPackage.Literals.FOR_EACH__BRANCH);
						
			}
		}
		
		
		@Check
		public void noRolesetSender(Message m) {
			if(m.getSender() instanceof RoleSet) {
				error("Sender of message must not be a role multiple",
						m,
						MyDslPackage.Literals.MESSAGE__SENDER);
			}
		}
		
		
		@Check
		public void messageToRolesetRef(GlobalProtocol glob_p) {
			List<Message> messageList = EcoreUtil2.getAllContentsOfType(glob_p, Message.class);
			var rolesetRef = getRolesetRef(glob_p);
			
			for(Message m : messageList) {
				if(m.getReceiver() instanceof RoleSet) {
					if(m.getSender() != rolesetRef.get(m.getReceiver())) {
						error(
							"Sender role must be referent of that Roleset",
							m,
							MyDslPackage.Literals.MESSAGE__SENDER
						);
					}
				}
			}
		}
		
		
		@Check
		public void rightForEachInteractions(GlobalProtocol glob_p) {
			//estraggo lista di foreach
			List<ForEach> eachList = EcoreUtil2.getAllContentsOfType(glob_p, ForEach.class);
			//estraggo lista di dichiarazione di roleset
			List<RoleSet> rolesetDef = EcoreUtil2.getAllContentsOfType(glob_p, RoleSet.class);
			
			//associo roleset a referente
			var references = new HashMap<RoleSet, RoleOne>();
			for(RoleSet r: rolesetDef) {
				references.put(r, r.getRef());
			}
			
			for(ForEach f : eachList) {
				//estraggo tutti i messaggi del foreach
				List<Message> messagesToCheck = EcoreUtil2.getAllContentsOfType(f, Message.class);
				
				for(Message mess : messagesToCheck) {
					if(mess.getReceiver() == f.getLoopRole()) {
						if(mess.getSender() != references.get(f.getRoleset())) {
							error("Sender of message must be reference of receiver",
									mess,
									MyDslPackage.Literals.MESSAGE__SENDER);
						}
					}
					
					if(mess.getSender() == f.getLoopRole()) {
						if(mess.getReceiver() != references.get(f.getRoleset())) {
							error("Receiver of message must be reference of sender",
									mess,
									MyDslPackage.Literals.MESSAGE__RECEIVER);
						}
					}
				}
				
			}
			
		}
		
		
		@Check
		public void uniqueRoleName(Model m) {
			//estraggo tutte le dichiarazioni di Role nel model
			List<Role> roles = EcoreUtil2.getAllContentsOfType(m, Roles.class).get(0).getRoles();
			//associazione nome ruolo dichiarato, oggetto Role
			var declaredRoles = new HashMap<String, Role>();
			
			for(Role r : roles) {
				if(declaredRoles.containsKey(r.getName())) {
					error("Role's name must be unique", 
							r,
							MyDslPackage.Literals.ROLE__NAME
							);
					
					error("Role's name must be unique", 
							declaredRoles.get(r.getName()),
							MyDslPackage.Literals.ROLE__NAME
							);
				} else {
					declaredRoles.put(r.getName(), r);
				}
			}
			
			//check variabili di loop ForEach, possono essere uguali tra loro ma non con i Role già in uso
			List<ForEach> forEachList = EcoreUtil2.getAllContentsOfType(m, ForEach.class);
			for(ForEach f : forEachList) {
				if(declaredRoles.containsKey(f.getLoopRole().getName())) {
					error("Role's name must be unique", 
							f.getLoopRole(),
							MyDslPackage.Literals.ROLE__NAME
							);
				}
			}
		}
	
}
