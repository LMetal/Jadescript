/*
 * generated by Xtext 2.34.0
 */
package org.xtext.globalTypes.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.globalTypes.myDsl.Model
import org.xtext.globalTypes.myDsl.Role
import org.xtext.globalTypes.myDsl.Protocol
import org.xtext.globalTypes.myDsl.Message
import org.xtext.globalTypes.myDsl.Choice
import org.xtext.globalTypes.myDsl.Recursion
import org.xtext.globalTypes.myDsl.CloseRecursion
import org.xtext.globalTypes.myDsl.ForEach
import org.xtext.globalTypes.myDsl.Roles
import org.xtext.globalTypes.myDsl.Payload
import org.xtext.globalTypes.myDsl.GlobalProtocol

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var model = resource.contents.head as Model;
		//create projection file(local protocol) for each role
		if(model.getProtocol() instanceof GlobalProtocol){
			var globalProtocol = model.protocol as GlobalProtocol
			for(Role r : globalProtocol.getRoles().getRoles()){
				fsa.generateFile('local'+r.getName()+'.jglobal', globalProtocol.project(r))
			}
		} else{
			var localProtocol = model as GlobalProtocol
			fsa.generateFile('jade'+model.protocol+'.txt', '''aaa''')
		}
		
		
	}
	
	def CharSequence project(GlobalProtocol p, Role role)'''
		local protocol «p.protocolName» projection on «role.name»(«projectOn(p.roles, role)») {
			«projectOn(p.protocol, role)»
			
		}
	'''
	
	def dispatch projectOn(Protocol protocol, Role role) '''
		«FOR a : protocol.actions»
			«projectOn(a, role)»
		«ENDFOR»
	'''
	
	def dispatch projectOn(Roles roles, Role r)'''
		«FOR role : roles.roles SEPARATOR ', '»role «IF role == r»self«ELSE»«role.name»«ENDIF»«ENDFOR»'''
	
	def dispatch projectOn(Message m, Role r)'''
		«IF m.sender == r»
			«m.messageType»(«printPayload(m.payload)») to «m.receiver.name»
		«ENDIF»
		«IF m.receiver == r»
			«m.messageType»(«printPayload(m.payload)») from «m.sender.name»
		«ENDIF»'''
	
	def dispatch projectOn(Choice c, Role r)'''
		choice at «IF c.role == r»self«ELSE»«c.role.name»«ENDIF»{
		«FOR int i: 0..c.branches.length-1 SEPARATOR' or {'»
				«projectOn(c.message.get(i), r)»
				«projectOn(c.branches.get(i), r)»
			}
		«ENDFOR»
	'''
	
	def dispatch projectOn(Recursion rec, Role r)'''
		rec «rec.name»:
	'''
	
	def dispatch projectOn(CloseRecursion recEnd, Role r)'''
		loop «recEnd.recursionVariable.name»;
	'''
	
	def dispatch projectOn(ForEach each, Role r)'''
		«IF each.role == r»
			«projectOn(each.branch, each.eachRole)»
		«ENDIF»
		«IF each.role !== r»
			foreach «each.eachRole.name»:«each.role.name»{
				«projectOn(each.branch, r)»
			}
		«ENDIF»
		
	'''
	
	def printPayload(Payload payload)'''
		«IF payload !== null»
			«FOR type: payload.types SEPARATOR ', '»«type»«ENDFOR»«ENDIF»'''
}