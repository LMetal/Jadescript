/*
 * generated by Xtext 2.34.0
 */
package org.xtext.globalTypes.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.globalTypes.myDsl.Model
import org.xtext.globalTypes.myDsl.Role
import org.xtext.globalTypes.myDsl.Protocol
import org.xtext.globalTypes.myDsl.Message
import org.xtext.globalTypes.myDsl.Choice
import org.xtext.globalTypes.myDsl.Recursion
import org.xtext.globalTypes.myDsl.CloseRecursion
import org.xtext.globalTypes.myDsl.ForEach
import org.xtext.globalTypes.myDsl.Roles
import org.xtext.globalTypes.myDsl.Payload
import org.xtext.globalTypes.myDsl.GlobalProtocol
import org.xtext.globalTypes.myDsl.LocalProtocol
import org.xtext.globalTypes.myDsl.RoleOne
import org.xtext.globalTypes.myDsl.RoleSet
import org.xtext.globalTypes.myDsl.MessageNormal
import org.xtext.globalTypes.myDsl.MessageQuit
import org.xtext.globalTypes.myDsl.EndProtocol
import org.eclipse.emf.common.util.EList
import org.xtext.globalTypes.myDsl.Definition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var model = resource.contents.head as Model;
		//create projection file(local protocol) for each role
		if(model.getProtocol() instanceof GlobalProtocol){
			var globalProtocol = model.protocol as GlobalProtocol
			for(Role r : globalProtocol.getRoles().getRoles()){
				System.out.println("LOCAL in " + r.getName());
				fsa.generateFile('../src/local/local_'+r.getName()+'.jglobal', globalProtocol.project(model.getDefinitions, r))
				System.out.println("END LOCAL on " + r.getName());		
			}
		} else {
			var localProtocol = model.protocol as LocalProtocol
			System.out.println("JADE");
			fsa.generateFile('jade/jade'+localProtocol.projectedRole+'.txt', '''aaa''')
		}
		
		
	}
	
	def CharSequence project(GlobalProtocol p, EList<Definition> definitions, Role role)'''
		Â«FOR d: definitionsÂ»
			Â«IF (d.type == '@proposition')Â»
				Â«d.typeÂ» Â«d.nameÂ»
			Â«ENDIFÂ»
			Â«IF (d.type == '@predicate')Â»
				Â«d.typeÂ» Â«d.nameÂ»(Â«FOR t : d.types SEPARATOR ', 'Â»Â«tÂ»Â«ENDFORÂ»)
			Â«ENDIFÂ»
			Â«IF (d.type == '@action')Â»
				Â«IF d.types.length != 0Â»
					Â«d.typeÂ» Â«d.nameÂ»(Â«FOR t : d.types SEPARATOR ', 'Â»Â«tÂ»Â«ENDFORÂ»)
				Â«ELSEÂ»
					Â«d.typeÂ» Â«d.nameÂ»
				Â«ENDIFÂ»
			Â«ENDIFÂ»
		Â«ENDFORÂ»
		
		local protocol Â«p.protocolNameÂ» at Â«projectOn(role, role)Â»(Â«projectOn(p.roles, role)Â») {
			Â«projectOn(p.protocol, role)Â»
		}
	'''
	
	def dispatch projectOn(Protocol protocol, Role role)'''
		Â«System.out.println("Project on here " + role.name)Â»
		Â«projectOn(protocol.begin, role)Â»'''
	
	def dispatch projectOn(Roles roles, Role r)
	'''Â«FOR role : roles.roles.filter[!name.equals(r.name)] SEPARATOR ', 'Â»Â«projectOn(role, r)Â»Â«ENDFORÂ»'''
	
		
	def dispatch projectOn(Role role, Role r)'''
		Â«IF role instanceof RoleOneÂ»role Â«role.nameÂ»Â«ELSEÂ»roleset Â«role.nameÂ»:Â«(role as RoleSet).ref.nameÂ»Â«ENDIFÂ»'''
	
	
	/*
	 * projection of a message on a role with differentiation between normal messages
	 * and quit messages. In the first case the protocol continues.
	 * 
	 * m: Message (superclass of MessageNormal and MessageQuit)
	 * r: role to project on
	 * 
	 * 
	 * (ğ‘¥ â†’ q â„“Quit ) â†¾ğœŒ q = ğ‘¥ ? â„“Quit
	 * (ğ‘¥ â†’ q â„“Quit ) â†¾ğœŒR = q!â„“Quit
	 * (ğ‘¥ â†’ q â„“Quit ) â†¾ğœŒ p = End
	 */
	def dispatch projectOn(Message m, Role r)'''
		Â«IF m instanceof MessageNormalÂ»
			Â«IF m.sender.name == r.nameÂ»
				Â«m.messageType.nameÂ»(Â«printPayload(m.payload)Â») to Â«m.receiver.nameÂ».
			Â«ELSEÂ»
				Â«IF m.receiver.name == r.nameÂ»
					Â«m.messageType.nameÂ»(Â«printPayload(m.payload)Â») from Â«m.sender.nameÂ».
				Â«ENDIFÂ»
			Â«ENDIFÂ»
			Â«projectOn(m.protocol, r)Â»
		Â«ELSEÂ»
			Â«IF m.sender.name == r.nameÂ»
				QUIT() to Â«m.receiver.nameÂ»
			Â«ELSEÂ»
				Â«IF m.receiver.name == r.nameÂ»
					QUIT() from Â«m.sender.nameÂ»
				Â«ELSEÂ»
					End
				Â«ENDIFÂ»
			Â«ENDIFÂ»
		Â«ENDIFÂ»
		'''

		
	/*
	 * p â†’ Q{ â„“ğ‘–âŸ¨Sğ‘–âŸ©.Gğ‘– }ğ‘–âˆˆğ¼ â†¾ğœŒ R = Q!{ â„“ğ‘–âŸ¨Sğ‘–âŸ©.Gğ‘– â†¾ğœŒ R }ğ‘–âˆˆğ¼ if RoleSet(p, ğœŒ) = R
	 * p â†’ Q{ â„“ğ‘–âŸ¨Sğ‘–âŸ©.Gğ‘– }ğ‘–âˆˆğ¼ â†¾ğœŒ R = p?{ â„“ğ‘–âŸ¨Sğ‘–âŸ©.Gğ‘– â†¾ğœŒ R }ğ‘–âˆˆğ¼ if RoleSet(Q, ğœŒ) = R
	 * p â†’ Q{ â„“ğ‘–âŸ¨Sğ‘–âŸ©.Gğ‘– }ğ‘–âˆˆğ¼ â†¾ğœŒ R = â¨†ï¸€ğ‘–âˆˆğ¼ Gğ‘– â†¾ğœŒ R //merge
	 */
	def dispatch projectOn(Choice c, Role r)'''
		Â«IF c.branches.get(0).getReceiver() == r || c.branches.get(0).getSender() == rÂ»
			choice at Â«c.role.nameÂ»{
			Â«FOR int i: 0..c.branches.length-1 SEPARATOR ' or {'Â»
					Â«projectOn(c.branches.get(i), r)Â»
				}
			Â«ENDFORÂ»
		Â«ELSEÂ»
			Â«MergeUtil.merge(c, r)Â»
		Â«ENDIFÂ»
	'''
	
	//only used by MERGE UTIL if merge is possible
	def safeProjectOn(Choice c, Role r)'''
		choice at Â«c.role.nameÂ»{
		Â«FOR int i: 0..c.branches.length-1 SEPARATOR ' or {'Â»
				Â«projectOn(c.branches.get(i), r)Â»
			}
		Â«ENDFORÂ»
	'''
	
	
	def dispatch projectOn(Recursion rec, Role r)'''
		rec Â«rec.nameÂ»: {
			Â«projectOn(rec.recProtocol, r)Â»
		}
	'''
	
	def dispatch projectOn(CloseRecursion recEnd, Role r)'''
		loop Â«recEnd.recursionVariable.nameÂ»
	'''
	
	def dispatch projectOn(ForEach each, Role r)'''
		Â«IF each.roleset == rÂ»
			Â«System.out.println("seq foreach start")Â»
			Â«seqOn(each.forBody, each.loopRole, each.roleset, each.protocol)Â»
		Â«ENDIFÂ»
		Â«IF each.refRole == rÂ»
			Â«System.out.println("project foreach start")Â»
			foreach role Â«each.loopRole.nameÂ»:<Â«each.roleset.nameÂ»,Â«each.refRole.nameÂ»>{
				Â«projectOn(each.forBody, r)Â»
			};
			Â«projectOn(each.protocol, r)Â»
		Â«ENDIFÂ»
	'''
	
	def dispatch projectOn(EndProtocol end, Role r)'''
		End
	'''
	
	def dispatch seqOn(Protocol protocol, Role role, Role roleset, Protocol p)'''
		Â«seqOn(protocol.begin, role, roleset, p)Â»'''
	
	def dispatch seqOn(Message m, Role r, Role rs, Protocol p)'''
		Â«System.out.println("seq message "+m.messageType)Â»
		Â«IF m instanceof MessageNormalÂ»
			Â«IF m.sender.name == r.nameÂ»
				Â«m.messageType.nameÂ»(Â«printPayload(m.payload)Â») to Â«m.receiver.nameÂ».
			Â«ELSEÂ»
				Â«IF m.receiver.name == r.nameÂ»
					Â«m.messageType.nameÂ»(Â«printPayload(m.payload)Â») from Â«m.sender.nameÂ».
				Â«ENDIFÂ»
			Â«ENDIFÂ»
			Â«seqOn(m.protocol, r, rs, p)Â»
		Â«ELSEÂ»
			Â«IF m.sender.name == r.nameÂ»
				QUIT() to Â«m.receiver.nameÂ»
			Â«ELSEÂ»
				Â«IF m.receiver.name == r.nameÂ»
					QUIT() from Â«m.sender.nameÂ»
				Â«ENDIFÂ»
			Â«ENDIFÂ»
		Â«ENDIFÂ»
	'''
	
	def dispatch seqOn(Choice c, Role r, Role rs, Protocol p)'''
		choice at Â«c.role.nameÂ»{
		Â«FOR int i: 0..c.branches.length-1 SEPARATOR ' or {'Â»
				Â«seqOn(c.branches.get(i), r, rs, p)Â»
			}
		Â«ENDFORÂ»
	'''

	def dispatch seqOn(Recursion rec, Role r, Role rs, Protocol p)'''
	Â«System.out.println("seq rec")Â»
		rec Â«rec.nameÂ»: {
			Â«seqOn(rec.recProtocol, r, rs, p)Â»
		}
	'''
	
	def dispatch seqOn(ForEach f, Role r, Role rs, Protocol p)'''
		Â«System.out.println("seq for")Â»
		Â«projectOn(f, rs)Â»
	'''
	
	def dispatch seqOn(CloseRecursion close, Role r, Role rs, Protocol p)'''
		Â«projectOn(close, r)Â»
	'''
	
	def dispatch seqOn(EndProtocol end, Role r, Role rs, Protocol p)'''
		Â«System.out.println("seq end")Â»
		Â«projectOn(p, rs)Â»
	'''
	
	def printPayload(Payload payload)'''
		Â«IF payload !== nullÂ»
			Â«FOR type: payload.types SEPARATOR ', 'Â»Â«typeÂ»Â«ENDFORÂ»Â«ENDIFÂ»'''
}